wfc_prefixdb - пакет модулей префиксного key-value хранилища на базе RocksDB
=========

На данный момент реализован один модуль, собсвенно prefixdb, состоящий из трех компонент:

* prefixdb - реализует основную логику, доступен напрямую из других модулей по интерфейсу iprefixdb
* prefixdb-service - обработчик входящих jsonrpc-запросов от модуля server-tcp или server-udp ( udp не реализовано)
* prefixdb-gateway - позволяет другим модулям обращатся к prefixdb(через prefixdb-service) удаленно

Планируються к разработке в ближайшее время:

* prefixdb-backup - полный и инкрементальный бэкап средствами RocksDB
* prefixdb-repli - репликация средствами RocksDB
* prefixdb-lua - поддержка Lua. Возможно полностью или частично будет реализован в prefixdb

В prefixdb - в каждом запросе указываеться префикс, а сами ключи передаются в "чистом" виде. Для каждого префикса, создаеться 
отдельное хранилище, представляющее собой директорию с именем префикса. Таким образом, единственное ограничение на имя префикса,
за исключением здравого смысла - это совместимость с файловой системой linux. Также очень желательно не использовать символы
требующие экранирования jsonrpc. Идеальный вариант - это латинские буквы, цифры и "_". Важно! нельзя префиксы на стороне клиента 
создавать динамически, иначе получим тот же бардак, что и с leveldb.

Префиксная реализация имеет следующие преемущества:

* Контролируемость. Всегда можно отследить ключи какого префикса генерируються неконтролируемо (нампример в ключ по ошибке 
внедрили timestamp) или хранятся значения неадекватных размеров (например кто-то решил фотки тут хранить).
* Управляемость. Можно простым копированием перенести данные одного или нескольких префиксов на другой сервер без перезапуска.
* Компактность. Префиксы не являються частью ключа - это всего лишь имя дериктории, где хранятся файлы хранилища. В явном виде
префикс нигде не храниться

Реализация на базе RocksDB по сравнению с LevelDB, дает следующие преемущества:

* Слияние! (мерджинг). Позволяет избавится от блокировок и уменьшить количество операций с диском, сохряняя при этом ту же надежность.
* Настраиваемость. Больше возможностей тюнинга, больше опций, которые вынесены в ini-файл (указывается в конфиге)
* Встроеный multi-get. В текущей версии RocksDB весьма условный
* Ускоряется перебор ключей. Тяжелая операция range (в leveldb get_range) теперь влияет только на тот префикс, из которого производиться выборка.
* встроеные механизмы backup и репликации на уровне файловой системы. Позволяет добиться 100% консистености, в отличие от 
сетевой репликации, которая не может дать таких гарантий
* встроенные механизмы восстановления (TODO)


Слияние (мерджинг) - мощный механизм обновления данных, которые требуют предарительного чтения, когда нужно прочитать данные, изменить и сохранить.
В реализации LevelDB чтобы, например, инкрементировать значение, нужно его прочитать, изменить и записать (Read->Modify->Write). 
В промежуток между этими операциями могут прийти другие модифицирующие запросы (наприме Delete), поэтому ключ надо блокировать,
чтобы не допустить изменений. 

Архитектура LevelDB (так же как и RocksDB) не имеет встроеного функционала блокирования ключей.
Поэтому нужно делать внешнюю блокировку. Блокировать все хранилище не эффективно по производительности, а создавать отдельный 
мьютекс на ключ накладно по ресурсам. Поэтому в демоне LevelDB мы работаем с пулом мьютексов, каждый из которых блокирует кратный
набор ключей по хэшу, что приводит хоть и не часто, к существенному увеличению времени ответа. 

Идея слияния заключается в следующем. Мы откладываем операцию обновления, например инкремента, на не определенный срок, 
например, до первой попытки получения значения. До этого момента могут прийти еще несколько запросов на обновление, 
котороы мы также отложим. В тот момент, когда нам необходимо получить значение ключа, происходит слияние. В результате 
которого на исходное значение, атамарно, накладываются все накопленные операции обновления, и только потом происходит 
запись и возврат результата на запрос.

Важно понимать, что отложенные операции также являються персистентными и реплицируемыми на уровне RocksDB. Т.е. в результате 
падения или перезапуска они не будут потеряны. 

# API

[PrefixDB API](http://github.lan/cpp/wfc_prefixdb/wikis/wfc_prefixdb)
